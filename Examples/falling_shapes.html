<!DOCTYPE html>
<html lang="en">
	<head>
		<title>JoltPhysics.js demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="style.css">
	</head>
	<body>
		<div id="container">Loading...</div>
		<div id="info">JoltPhysics.js demo</div>

		<script src="js/jolt.js"></script>
		<script src="js/three/three.min.js"></script>
		<script src="js/three/OrbitControls.js"></script>
		<script src="js/three/WebGL.js"></script>
		<script src="js/three/stats.min.js"></script>
		<script src="js/example.js"></script>

		<script>

			Jolt().then(function (Jolt) {

				// List of objects spawned
				var dynamicObjects = [];

				// Spawning variables
				var objectTimePeriod = 0.25;
				var timeNextSpawn = time + objectTimePeriod;
				var maxNumObjects = 100;

				// Initialize this example
				initExample(onUpdate);

				// Create a basic floor
				createFloor();

				function generateObject() {

					var numTypes = 5;
					var objectType = Math.ceil(Math.random() * numTypes);

					var threeObject = null;
					var shape = null;

					var material = new THREE.MeshPhongMaterial({ color: Math.floor(Math.random() * (1 << 24)) });

					switch (objectType) {
						case 1:
							// Sphere
							var radius = 0.5 + Math.random();
							threeObject = new THREE.Mesh(new THREE.SphereGeometry(radius, 20, 20), material);
							shape = new Jolt.SphereShape(radius, null);
							break;

						case 2:
							// Box
							var sx = 1 + Math.random();
							var sy = 1 + Math.random();
							var sz = 1 + Math.random();
							threeObject = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), material);
							shape = new Jolt.BoxShape(new Jolt.Vec3(sx * 0.5, sy * 0.5, sz * 0.5), 0.002, null);
							break;

						case 3:
							// Cylinder
							var radius = 0.5 + Math.random();
							var height = 1 + Math.random();
							threeObject = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, height, 20, 1), material);
							shape = new Jolt.CylinderShape(height * 0.5, radius, 0.002, null);
							break;

						case 4:
							// Capsule
							var radius = 0.5 + Math.random();
							var height = 1 + Math.random();
							threeObject = new THREE.Mesh(new THREE.CapsuleGeometry(radius, height, 20, 10), material);
							shape = new Jolt.CapsuleShape(height * 0.5, radius, null);
							break;

						case 5:
							// Convex hull
							var hull = new Jolt.ConvexHullShapeSettings;
							for (var p = 0; p < 10; ++p)
								hull.mPoints.push_back(new Jolt.Vec3(-0.5 + 2 * Math.random(), -0.5 + 2 * Math.random(), -0.5 + 2 * Math.random()));
							shape = hull.Create().Get();

							// Get triangle data
							var triContext = new Jolt.ShapeGetTriangles(shape, Jolt.AABox.prototype.sBiggest(), shape.GetCenterOfMass(), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(1, 1, 1));

							// Get a view on the triangle data (does not make a copy)
							var vertices = new Float32Array(Jolt.HEAPF32.buffer, triContext.GetVerticesData(), triContext.GetVerticesSize());

							// Create a three object
							const geometry = new THREE.BufferGeometry();
							geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
							geometry.computeVertexNormals();
							threeObject = new THREE.Mesh(geometry, material)
							break;
					}

					// Position and rotate visual mesh
					threeObject.position.set((Math.random() - 0.5) * 25, 10, (Math.random() - 0.5) * 25);
					threeObject.quaternion.random();

					// Create physics body
					var pos = threeObject.position, rot = threeObject.quaternion;
					var creation_settings = new Jolt.BodyCreationSettings(shape, new Jolt.Vec3(pos.x, pos.y, pos.z), new Jolt.Quat(rot.x, rot.y, rot.z, rot.w), Jolt.Dynamic, Jolt.MOVING);
					creation_settings.mRestitution = 0.5;
					var body = bodyInterface.CreateBody(creation_settings);
					bodyInterface.AddBody(body.GetID(), Jolt.Activate);
					threeObject.userData.body = body;

					scene.add(threeObject);
					dynamicObjects.push(threeObject);
				}

				function onUpdate(time, deltaTime) {

					// Check if its time to spawn a new object
					if (dynamicObjects.length < maxNumObjects && time > timeNextSpawn) {
						generateObject();
						timeNextSpawn = time + objectTimePeriod;
					}

					// Update object transforms
					for (var i = 0, il = dynamicObjects.length; i < il; i++) {
						var objThree = dynamicObjects[i];
						var body = dynamicObjects[i].userData.body;
						var p = body.GetPosition();
						var q = body.GetRotation();
						objThree.position.set(p.GetX(), p.GetY(), p.GetZ());
						objThree.quaternion.set(q.GetX(), q.GetY(), q.GetZ(), q.GetW());
					}
				}
			});

		</script>
	</body>
</html>
