<!DOCTYPE html>
<html lang="en">

<head>
	<title>JoltPhysics.js demo</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
	<div id="container">Loading...</div>
	<div id="info">JoltPhysics.js demo</div>

	<script src="js/three/three.min.js"></script>
	<script src="js/three/OrbitControls.js"></script>
	<script src="js/three/WebGL.js"></script>
	<script src="js/three/stats.min.js"></script>
	<script src="js/example.js"></script>

	<script type="module">
		import initJolt from './js/jolt-physics.wasm-compat.js';
		const JPH_PI = 3.14159265358979323846;
		const DegreesToRadians = (deg) => deg * (JPH_PI / 180.0);

		initJolt().then(function (Jolt) {
			window.Jolt = Jolt;

			// Initialize this example
			container = document.getElementById('container');
			container.innerHTML = "";
			initPhysics();
			initGraphics();

			const cCharacterHeightStanding = 2;
			const cCharacterRadiusStanding = 1;
			const cCharacterHeightCrouching = 0.8;
			const cCharacterRadiusCrouching = 0.3;

			// Character movement properties
			const sControlMovementDuringJump = true;					///< If false the character cannot change movement direction in mid air
			const sCharacterSpeed = 6.0;
			const sJumpSpeed = 4.0;

			const sEnableCharacterInertia = true;

			const sBackFaceMode = Jolt.CollideWithBackFaces;
			const sUpRotationX = 0;
			const sUpRotationZ = 0;
			const sMaxSlopeAngle = DegreesToRadians(45.0);
			const sMaxStrength = 100.0;
			const sCharacterPadding = 0.02;
			const sPenetrationRecoverySpeed = 1.0;
			const sPredictiveContactDistance = 0.1;
			const sEnableWalkStairs = true;
			const sEnableStickToFloor = true;

			const sShapeType = 'Capsule';
			let mStandingShape;
			let mCrouchingShape;
			let mThreeStandingGeometry;
			let mThreeCrouchingGeometry;

			let mCharacter;
			let mAllowSliding = false;

			const geometry = new THREE.BoxGeometry(1, 1, 1);
			const material = new THREE.MeshPhongMaterial({ color: 0xffff00 });
			let mThreeCharacter = new THREE.Mesh(geometry, material);
			let mDesiredVelocity = new THREE.Vector3();

			const update_settings = new Jolt.ExtendedUpdateSettings();

			const objectVsBroadPhaseLayerFilter = jolt.GetObjectVsBroadPhaseLayerFilter();
			const objectLayerPairFilter = jolt.GetObjectLayerPairFilter();


			const movingBPFilter = new Jolt.DefaultBroadPhaseLayerFilter(objectVsBroadPhaseLayerFilter, Jolt.MOVING);
			const movingLayerFilter = new Jolt.DefaultObjectLayerFilter(objectLayerPairFilter, Jolt.MOVING);
			const bodyFilter = new Jolt.BodyFilter();
			const shapeFilter = new Jolt.ShapeFilter();

			const wrapVec3 = (joltVec3) => new THREE.Vector3(joltVec3.GetX(), joltVec3.GetY(), joltVec3.GetZ());
			const wrapQuat = (q) => new THREE.Quaternion(q.GetX(), q.GetY(), q.GetZ(), q.GetW());

			const initShape = () => {
				const inPositionStanding = new Jolt.Vec3(0, 0.5 * cCharacterHeightStanding + cCharacterRadiusStanding, 0);
				const inPositionCrouching = new Jolt.Vec3(0, 0.5 * cCharacterHeightCrouching + cCharacterRadiusCrouching, 0);
				const inRotation = Jolt.Quat.prototype.sIdentity();

				switch (sShapeType) {
					case 'Capsule':
						mStandingShape = new Jolt.RotatedTranslatedShapeSettings(inPositionStanding, inRotation, new Jolt.CapsuleShapeSettings(0.5 * cCharacterHeightStanding, cCharacterRadiusStanding)).Create().Get();
						mCrouchingShape = new Jolt.RotatedTranslatedShapeSettings(inPositionCrouching, inRotation, new Jolt.CapsuleShapeSettings(0.5 * cCharacterHeightCrouching, cCharacterRadiusCrouching)).Create().Get();

						mThreeStandingGeometry = new THREE.CapsuleGeometry(cCharacterRadiusStanding, cCharacterHeightStanding, 4, 8).translate(0, 0.5 * cCharacterHeightStanding + cCharacterRadiusStanding, 0);
						mThreeCrouchingGeometry = new THREE.CapsuleGeometry(cCharacterRadiusCrouching, cCharacterHeightCrouching, 4, 8).translate(0, 0.5 * cCharacterHeightCrouching + cCharacterRadiusCrouching, 0);
						break;

					case 'Cylinder':
						mStandingShape = new Jolt.RotatedTranslatedShapeSettings(inPositionStanding, inRotation, new Jolt.CylinderShapeSettings(0.5 * cCharacterHeightStanding + cCharacterRadiusStanding, cCharacterRadiusStanding)).Create().Get();
						mCrouchingShape = new Jolt.RotatedTranslatedShapeSettings(inPositionCrouching, inRotation, new Jolt.CylinderShapeSettings(0.5 * cCharacterHeightCrouching + cCharacterRadiusCrouching, cCharacterRadiusCrouching)).Create().Get();

						mThreeStandingGeometry = new THREE.CylinderGeometry(cCharacterRadiusStanding, cCharacterRadiusStanding, 2 * cCharacterRadiusStanding + cCharacterHeightStanding, 8, 4).translate(0, 0.5 * cCharacterHeightStanding + cCharacterRadiusStanding, 0);
						mThreeCrouchingGeometry = new THREE.CylinderGeometry(cCharacterRadiusCrouching, cCharacterRadiusCrouching, 2 * cCharacterRadiusCrouching + cCharacterHeightCrouching, 8, 4).translate(0, 0.5 * cCharacterHeightCrouching + cCharacterRadiusCrouching, 0);
						break;

					case 'Box':
						mStandingShape = new Jolt.RotatedTranslatedShapeSettings(inPositionStanding, inRotation, new Jolt.BoxShapeSettings(new Jolt.Vec3(cCharacterRadiusStanding, 0.5 * cCharacterHeightStanding + cCharacterRadiusStanding, cCharacterRadiusStanding))).Create().Get();
						mCrouchingShape = new Jolt.RotatedTranslatedShapeSettings(inPositionCrouching, inRotation, new Jolt.BoxShapeSettings(new Jolt.Vec3(cCharacterRadiusCrouching, 0.5 * cCharacterHeightCrouching + cCharacterRadiusCrouching, cCharacterRadiusCrouching))).Create().Get();

						mThreeStandingGeometry = new THREE.BoxGeometry(2 * cCharacterRadiusStanding, 2 * cCharacterRadiusStanding + cCharacterHeightStanding, 2 * cCharacterRadiusStanding).translate(0, 0.5 * cCharacterHeightStanding + cCharacterRadiusStanding, 0);
						mThreeCrouchingGeometry = new THREE.BoxGeometry(2 * cCharacterRadiusStanding, 2 * cCharacterRadiusCrouching + cCharacterHeightCrouching, 2 * cCharacterRadiusCrouching).translate(0, 0.5 * cCharacterHeightCrouching + cCharacterRadiusCrouching, 0);
						break;
				}
			}
			const initalize = () => {
				initShape();
				const settings = new Jolt.CharacterVirtualSettings();
				settings.mMaxSlopeAngle = sMaxSlopeAngle;
				settings.mMaxStrength = sMaxStrength;
				settings.mShape = mStandingShape;
				settings.mBackFaceMode = sBackFaceMode;
				settings.mCharacterPadding = sCharacterPadding;
				settings.mPenetrationRecoverySpeed = sPenetrationRecoverySpeed;
				settings.mPredictiveContactDistance = sPredictiveContactDistance;
				settings.mSupportingVolume = new Jolt.Plane(Jolt.Vec3.prototype.sAxisY(), -cCharacterRadiusStanding);
				mCharacter = new Jolt.CharacterVirtual(settings, Jolt.Vec3.prototype.sZero(), Jolt.Quat.prototype.sIdentity(), physicsSystem);

				mThreeCharacter.geometry = mThreeStandingGeometry;
				mThreeCharacter.userData.body = mCharacter;

				scene.add(mThreeCharacter);
				dynamicObjects.push(mThreeCharacter);
			}

			const prePhysicsUpdate = (mDeltaTime) => {
				const characterUp = wrapVec3(mCharacter.GetUp());
				if (!sEnableStickToFloor) {
					update_settings.mStickToFloorStepDown = Jolt.Vec3.prototype.sZero();
				}
				else {
					const vec = characterUp.clone().multiplyScalar(-update_settings.mStickToFloorStepDown.Length());
					update_settings.mStickToFloorStepDown = new Jolt.Vec3(vec.x, vec.y, vec.z);
				}

				if (!sEnableWalkStairs) {
					update_settings.mWalkStairsStepUp = Jolt.Vec3.prototype.sZero();
				}
				else {
					const vec = characterUp.clone().multiplyScalar(update_settings.mWalkStairsStepUp.Length());
					update_settings.mWalkStairsStepUp = new Jolt.Vec3(vec.x, vec.y, vec.z);
				}
				characterUp.multiplyScalar(-physicsSystem.GetGravity().Length());
				mCharacter.ExtendedUpdate(mDeltaTime,
					new Jolt.Vec3(characterUp.x, characterUp.y, characterUp.z),
					update_settings,
					movingBPFilter,
					movingLayerFilter,
					bodyFilter,
					shapeFilter,
					jolt.GetTempAllocator());
			}

			const handleInput = (inMovementDirection /* Vector3 */, inJump, inSwitchStance, inDeltaTime) => {
				const player_controls_horizontal_velocity = sControlMovementDuringJump || mCharacter.IsSupported();
				if (player_controls_horizontal_velocity) {
					// True if the player intended to move
					mAllowSliding = !(inMovementDirection.length() < 1.0e-12);
					// Smooth the player input
					if (sEnableCharacterInertia) {
						mDesiredVelocity.multiplyScalar(0.75).add(inMovementDirection.multiplyScalar(0.25 * sCharacterSpeed))
					} else {
						mDesiredVelocity.copy(inMovementDirection).multiplyScalar(sCharacterSpeed);
					}
				}
				else {
					// While in air we allow sliding
					mAllowSliding = true;
				}
				const character_up_rotation = Jolt.Quat.prototype.sEulerAngles(new Jolt.Vec3(sUpRotationX, 0, sUpRotationZ));
				mCharacter.SetUp(character_up_rotation.RotateAxisY());
				mCharacter.SetRotation(character_up_rotation);
				const upRotation = wrapQuat(character_up_rotation);

				mCharacter.UpdateGroundVelocity();
				const characterUp = wrapVec3(mCharacter.GetUp());
				const linearVelocity = wrapVec3(mCharacter.GetLinearVelocity());
				const current_vertical_velocity = characterUp.clone().multiplyScalar(linearVelocity.dot(characterUp));
				const ground_velocity = wrapVec3(mCharacter.GetGroundVelocity());
				const gravity = wrapVec3(physicsSystem.GetGravity());

				let new_velocity;
				const moving_towards_ground = (current_vertical_velocity.x - ground_velocity.y) < 0.1;
				if (mCharacter.GetGroundState() == Jolt.OnGround	// If on ground
					&& (sEnableCharacterInertia ?
						moving_towards_ground													// Inertia enabled: And not moving away from ground
						: !mCharacter.IsSlopeTooSteep(mCharacter.GetGroundNormal())))			// Inertia disabled: And not on a slope that is too steep
				{
					// Assume velocity of ground when on ground
					new_velocity = ground_velocity;

					// Jump
					if (inJump && moving_towards_ground)
						new_velocity.add(characterUp.multiplyScalar(sJumpSpeed));
				}
				else
					new_velocity = current_vertical_velocity.clone();


				// Gravity
				new_velocity.add(gravity.multiplyScalar(inDeltaTime).applyQuaternion(upRotation));

				if (player_controls_horizontal_velocity) {
					// Player input
					new_velocity.add(mDesiredVelocity.clone().applyQuaternion(upRotation));
				}
				else {
					// Preserve horizontal velocity
					const current_horizontal_velocity = linearVelocity.sub(current_vertical_velocity);
					new_velocity.add(current_horizontal_velocity);
				}

				mCharacter.SetLinearVelocity(new Jolt.Vec3(new_velocity.x, new_velocity.y, new_velocity.z));

				if (inSwitchStance) {
					let newShape;
					if (mCharacter.GetShape() == mStandingShape) {
						newShape = mCrouchingShape;
						mThreeCharacter.geometry = mThreeCrouchingGeometry;
					} else {
						newShape = mStandingShape;
						mThreeCharacter.geometry = mThreeStandingGeometry;
					}
					mCharacter.SetShape(newShape,
						1.5 * physicsSystem.GetPhysicsSettings().mPenetrationSlop,
						movingBPFilter,
						movingLayerFilter,
						bodyFilter,
						shapeFilter,
						jolt.GetTempAllocator());
				}
			}


			// Create a basic floor
			createFloor();


			createBox(new Jolt.Vec3(-45, 1, 0), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(0.5, 2, 45), Jolt.Static, Jolt.NON_MOVING);
			createBox(new Jolt.Vec3(45, 1, 0), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(0.5, 2, 45), Jolt.Static, Jolt.NON_MOVING);

			let stepHeight = 0.3;
			for (let i = 1; i < 10; i++) {
				createBox(new Jolt.Vec3(15, i * stepHeight - 0.5 + stepHeight / 2, -20 - i * 3), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(2, stepHeight / 2, 2), Jolt.Static, Jolt.NON_MOVING);
			}
			stepHeight = 0.4;
			for (let i = 1; i < 10; i++) {
				createBox(new Jolt.Vec3(20, i * stepHeight - 0.5 + stepHeight / 2, -20 - i * 3), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(2, stepHeight / 2, 2), Jolt.Static, Jolt.NON_MOVING);
			}
			stepHeight = 0.5;
			for (let i = 1; i < 10; i++) {
				createBox(new Jolt.Vec3(25, i * stepHeight - 0.5 + stepHeight / 2, -20 - i * 3), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(2, stepHeight / 2, 2), Jolt.Static, Jolt.NON_MOVING);
			}
			stepHeight = 0.6;
			for (let i = 1; i < 10; i++) {
				createBox(new Jolt.Vec3(30, i * stepHeight - 0.5 + stepHeight / 2, -20 - i * 3), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(2, stepHeight / 2, 2), Jolt.Static, Jolt.NON_MOVING);
			}
			stepHeight = 0.7;
			for (let i = 1; i < 10; i++) {
				createBox(new Jolt.Vec3(35, i * stepHeight - 0.5 + stepHeight / 2, -20 - i * 3), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(2, stepHeight / 2, 2), Jolt.Static, Jolt.NON_MOVING);
			}

			for (let i = 0; i < 10; i++) {
				createBox(new Jolt.Vec3(-40 + 5 * i, 2, -25), Jolt.Quat.prototype.sRotation(new Jolt.Vec3(1, 0, 0), DegreesToRadians(70 - i * 5.0)), new Jolt.Vec3(2.5, 0.6, 8), Jolt.Static, Jolt.NON_MOVING);
			}

			initalize();

			const input = {
				direction: new THREE.Vector3(),
				jump: false,
				switchStance: false
			}

			onExampleUpdate = (time, deltaTime) => {
				handleInput(input.direction.clone(), input.jump, input.switchStance, deltaTime);
				prePhysicsUpdate(deltaTime)
			}

			document.addEventListener("keydown", onDocumentKeyDown, false);
			document.addEventListener("keyup", onDocumentKeyUp, false);
			function onDocumentKeyDown(event) {
				var keyCode = event.which;
				if (keyCode == 87) {
					input.direction.z = -2;
				} else if (keyCode == 83) {
					input.direction.z = 2;
				} else if (keyCode == 65) {
					input.direction.x = -2;
				} else if (keyCode == 68) {
					input.direction.x = 2;
				} else if (keyCode == 32) {
					input.jump = true;
				}
			};
			function onDocumentKeyUp(event) {
				var keyCode = event.which;
				if (keyCode == 87) {
					input.direction.z = 0;
				} else if (keyCode == 83) {
					input.direction.z = 0;
				} else if (keyCode == 65) {
					input.direction.x = 0;
				} else if (keyCode == 68) {
					input.direction.x = 0;
				} else if (keyCode == 32) {
					input.jump = false;
				}
			};

			renderExample();
		});

	</script>
</body>

</html>